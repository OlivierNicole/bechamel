<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bechamel__Analyze (bechamel.Bechamel__Analyze)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0-359-g492257c"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> – <a href="../index.html">bechamel</a> &#x00BB; Bechamel__Analyze</nav><header><h1>Module <code>Bechamel__Analyze</code></h1><p>Analyze module.</p><p>Micro-benchmark usually uses a <i>linear-regression</i> to estimates the execution time of a code segments. For example, the following table might represent <code>{!Measurement_raw.t} array</code> collected by <code>Benchmark</code>.run:</p><pre>  +-----+------+
  | run | time |
  +-----+------+
  | 1   | 19   |
  | 2   | 25   |
  | 3   | 37   |
  | 4   | 47   |
  | 5   | 56   |
  +-----+------+</pre><p>Bechamel records 3000 samples and the number of iterations can grows geometrically (see <code>Benchmark</code>.run). Then, Bechamel can use 2 algorithms:</p><ul><li>Ordinary Least Square</li><li>RANdom SAmple Consensus</li></ul><p>The user can choose one of it. Currently, <code>OLS</code> is the best to use. These algorithms will estimate the actual execution time of the code segment. Using <code>OLS</code> with the above data would yield an estimated execution time of <code>9.6</code> nanoseconds with a goodness of fit (<code>r²</code>) of <code>0.992</code>.</p><p>More generally, Bechamel lets the user to choose <i>predictors</i> and the <i>responder</i>. Indeed, the user can use others metrics (such as <code>perf</code>) and the API allows to analyze such metrics each other.</p></header><div class="content"></div></body></html>